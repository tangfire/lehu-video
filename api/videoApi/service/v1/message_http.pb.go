// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             v3.20.3
// source: api/videoApi/service/v1/message.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationMessageServiceDeleteConversation = "/api.videoApi.service.v1.MessageService/DeleteConversation"
const OperationMessageServiceListConversations = "/api.videoApi.service.v1.MessageService/ListConversations"
const OperationMessageServiceListMessages = "/api.videoApi.service.v1.MessageService/ListMessages"
const OperationMessageServiceMarkMessagesRead = "/api.videoApi.service.v1.MessageService/MarkMessagesRead"
const OperationMessageServiceRecallMessage = "/api.videoApi.service.v1.MessageService/RecallMessage"
const OperationMessageServiceSendMessage = "/api.videoApi.service.v1.MessageService/SendMessage"

type MessageServiceHTTPServer interface {
	// DeleteConversation 删除会话
	DeleteConversation(context.Context, *DeleteConversationReq) (*DeleteConversationResp, error)
	// ListConversations 获取会话列表
	ListConversations(context.Context, *ListConversationsReq) (*ListConversationsResp, error)
	// ListMessages 获取消息列表
	ListMessages(context.Context, *ListMessagesReq) (*ListMessagesResp, error)
	// MarkMessagesRead 标记消息已读
	MarkMessagesRead(context.Context, *MarkMessagesReadReq) (*MarkMessagesReadResp, error)
	// RecallMessage 撤回消息
	RecallMessage(context.Context, *RecallMessageReq) (*RecallMessageResp, error)
	// SendMessage 发送消息
	SendMessage(context.Context, *SendMessageReq) (*SendMessageResp, error)
}

func RegisterMessageServiceHTTPServer(s *http.Server, srv MessageServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/message", _MessageService_SendMessage0_HTTP_Handler(srv))
	r.GET("/v1/messages", _MessageService_ListMessages0_HTTP_Handler(srv))
	r.DELETE("/v1/message/{message_id}", _MessageService_RecallMessage0_HTTP_Handler(srv))
	r.POST("/v1/messages/read", _MessageService_MarkMessagesRead0_HTTP_Handler(srv))
	r.GET("/v1/conversations", _MessageService_ListConversations0_HTTP_Handler(srv))
	r.DELETE("/v1/conversation/{conversation_id}", _MessageService_DeleteConversation0_HTTP_Handler(srv))
}

func _MessageService_SendMessage0_HTTP_Handler(srv MessageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SendMessageReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMessageServiceSendMessage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SendMessage(ctx, req.(*SendMessageReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SendMessageResp)
		return ctx.Result(200, reply)
	}
}

func _MessageService_ListMessages0_HTTP_Handler(srv MessageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListMessagesReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMessageServiceListMessages)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListMessages(ctx, req.(*ListMessagesReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListMessagesResp)
		return ctx.Result(200, reply)
	}
}

func _MessageService_RecallMessage0_HTTP_Handler(srv MessageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RecallMessageReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMessageServiceRecallMessage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RecallMessage(ctx, req.(*RecallMessageReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RecallMessageResp)
		return ctx.Result(200, reply)
	}
}

func _MessageService_MarkMessagesRead0_HTTP_Handler(srv MessageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MarkMessagesReadReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMessageServiceMarkMessagesRead)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.MarkMessagesRead(ctx, req.(*MarkMessagesReadReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MarkMessagesReadResp)
		return ctx.Result(200, reply)
	}
}

func _MessageService_ListConversations0_HTTP_Handler(srv MessageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListConversationsReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMessageServiceListConversations)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListConversations(ctx, req.(*ListConversationsReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListConversationsResp)
		return ctx.Result(200, reply)
	}
}

func _MessageService_DeleteConversation0_HTTP_Handler(srv MessageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteConversationReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMessageServiceDeleteConversation)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteConversation(ctx, req.(*DeleteConversationReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteConversationResp)
		return ctx.Result(200, reply)
	}
}

type MessageServiceHTTPClient interface {
	DeleteConversation(ctx context.Context, req *DeleteConversationReq, opts ...http.CallOption) (rsp *DeleteConversationResp, err error)
	ListConversations(ctx context.Context, req *ListConversationsReq, opts ...http.CallOption) (rsp *ListConversationsResp, err error)
	ListMessages(ctx context.Context, req *ListMessagesReq, opts ...http.CallOption) (rsp *ListMessagesResp, err error)
	MarkMessagesRead(ctx context.Context, req *MarkMessagesReadReq, opts ...http.CallOption) (rsp *MarkMessagesReadResp, err error)
	RecallMessage(ctx context.Context, req *RecallMessageReq, opts ...http.CallOption) (rsp *RecallMessageResp, err error)
	SendMessage(ctx context.Context, req *SendMessageReq, opts ...http.CallOption) (rsp *SendMessageResp, err error)
}

type MessageServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewMessageServiceHTTPClient(client *http.Client) MessageServiceHTTPClient {
	return &MessageServiceHTTPClientImpl{client}
}

func (c *MessageServiceHTTPClientImpl) DeleteConversation(ctx context.Context, in *DeleteConversationReq, opts ...http.CallOption) (*DeleteConversationResp, error) {
	var out DeleteConversationResp
	pattern := "/v1/conversation/{conversation_id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMessageServiceDeleteConversation))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *MessageServiceHTTPClientImpl) ListConversations(ctx context.Context, in *ListConversationsReq, opts ...http.CallOption) (*ListConversationsResp, error) {
	var out ListConversationsResp
	pattern := "/v1/conversations"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMessageServiceListConversations))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *MessageServiceHTTPClientImpl) ListMessages(ctx context.Context, in *ListMessagesReq, opts ...http.CallOption) (*ListMessagesResp, error) {
	var out ListMessagesResp
	pattern := "/v1/messages"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMessageServiceListMessages))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *MessageServiceHTTPClientImpl) MarkMessagesRead(ctx context.Context, in *MarkMessagesReadReq, opts ...http.CallOption) (*MarkMessagesReadResp, error) {
	var out MarkMessagesReadResp
	pattern := "/v1/messages/read"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationMessageServiceMarkMessagesRead))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *MessageServiceHTTPClientImpl) RecallMessage(ctx context.Context, in *RecallMessageReq, opts ...http.CallOption) (*RecallMessageResp, error) {
	var out RecallMessageResp
	pattern := "/v1/message/{message_id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMessageServiceRecallMessage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *MessageServiceHTTPClientImpl) SendMessage(ctx context.Context, in *SendMessageReq, opts ...http.CallOption) (*SendMessageResp, error) {
	var out SendMessageResp
	pattern := "/v1/message"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationMessageServiceSendMessage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
